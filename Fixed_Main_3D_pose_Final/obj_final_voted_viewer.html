<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Body Mesh Viewer - Final Voted Skeleton</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #ffffff;
            overflow: hidden;
        }
        #container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        #header {
            padding: 20px 30px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        #header h1 {
            margin: 0 0 15px 0;
            font-size: 32px;
            font-weight: 600;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            background: linear-gradient(90deg, #fff, #e0e0e0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        #frame-control {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 15px;
        }
        #frame-control button {
            padding: 10px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 16px;
            font-weight: 600;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        #frame-control button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        }
        #frame-control button:disabled {
            background: rgba(100, 100, 100, 0.5);
            cursor: not-allowed;
            transform: none;
            border-color: rgba(255, 255, 255, 0.1);
        }
        #frame-info {
            font-size: 24px;
            font-weight: bold;
            color: #ffffff;
            min-width: 200px;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }
        #controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        #controls button {
            padding: 8px 20px;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: 500;
            backdrop-filter: blur(5px);
        }
        #controls button:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        #controls button.active {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border-color: rgba(255, 255, 255, 0.5);
            box-shadow: 0 0 15px rgba(245, 87, 108, 0.5);
        }
        #viewport-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            height: calc(100vh - 200px);
        }
        #viewport {
            position: relative;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            width: 90%;
            max-width: 1400px;
            height: 100%;
        }
        #viewport canvas {
            width: 100% !important;
            height: 100% !important;
            display: block;
            border-radius: 15px;
        }
        .viewport-label {
            position: absolute;
            top: 20px;
            left: 20px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.9) 0%, rgba(118, 75, 162, 0.9) 100%);
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            z-index: 10;
            pointer-events: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
        }
        .viewport-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            z-index: 10;
            pointer-events: none;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .viewport-quality {
            position: absolute;
            top: 70px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px 20px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 10;
            pointer-events: none;
            max-width: 350px;
            line-height: 1.6;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .quality-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 8px;
            color: #4ade80;
            text-shadow: 0 0 10px rgba(74, 222, 128, 0.5);
        }
        .quality-metric {
            margin: 6px 0;
            padding: 6px 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            border-left: 3px solid #4ade80;
        }
        .quality-value {
            font-weight: bold;
            color: #4ade80;
        }
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.95) 0%, rgba(118, 75, 162, 0.95) 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            flex-direction: column;
            backdrop-filter: blur(10px);
        }
        #loading.hidden {
            display: none;
        }
        .spinner {
            border: 5px solid rgba(255, 255, 255, 0.2);
            border-top: 5px solid #ffffff;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin-bottom: 25px;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #loading-text {
            font-size: 20px;
            font-weight: 500;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        .badge {
            display: inline-block;
            padding: 4px 12px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border-radius: 20px;
            font-size: 11px;
            font-weight: bold;
            margin-left: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <div id="loading-text">ìµœì  ìŠ¤ì¼ˆë ˆí†¤ ëª¨ë¸ ë¡œë”© ì¤‘...</div>
    </div>
    
    <div id="container">
        <div id="header">
            <h1>
                ğŸ† 3D Body Mesh - Final Voted Skeleton
                <span class="badge">ENSEMBLE</span>
            </h1>
            <div id="controls">
                <button id="resetCamera">ì¹´ë©”ë¼ ë¦¬ì…‹</button>
                <button id="toggleWireframe">ì™€ì´ì–´í”„ë ˆì„ í† ê¸€</button>
                <button id="toggleGrid">ê·¸ë¦¬ë“œ í† ê¸€</button>
                <button id="toggleSkeleton" class="active">ìŠ¤ì¼ˆë ˆí†¤ í† ê¸€</button>
                <button id="autoRotate">ìë™ íšŒì „</button>
            </div>
        </div>
        <div id="viewport-container">
            <div id="viewport">
                <div class="viewport-label">Default Quality - Voted Skeleton</div>
                <div class="viewport-quality" id="quality"></div>
                <div class="viewport-info" id="info"></div>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // í˜„ì¬ í”„ë ˆì„ ë²ˆí˜¸ (ì‚¬ìš© ì•ˆ í•¨)
        let currentFrame = 0;
        const totalFrames = 1; // ë‹¨ì¼ ëª¨ë¸ë§Œ ì‚¬ìš©

        // ëª¨ë¸ íŒŒì¼ ì„¤ì • í•¨ìˆ˜
        function getModelForFrame(frameNum) {
            return { 
                name: 'Default Quality', 
                file: `output/3d_models/body_mesh_fpfh.obj`, 
                skeletonFile: `output/3d_models/skeleton_data_voted_ensemble.json`
            };
        }

        let model = getModelForFrame(currentFrame);
        let skeletonData = null;

        // ë·°í¬íŠ¸ ì„¤ì •
        let scene, camera, renderer, controls, gridHelper, mesh, skeleton;
        let wireframeMode = false;
        let showGrid = true;
        let autoRotateEnabled = false;
        let showSkeleton = true;

        // ì´ˆê¸°í™”
        function init() {
            console.log('Initializing viewer...');
            
            const viewportDiv = document.getElementById('viewport');
            const width = viewportDiv.clientWidth;
            const height = viewportDiv.clientHeight;

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);

            // Camera
            camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 10000);
            camera.position.set(0, 100, 300);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            renderer.shadowMap.enabled = true;
            renderer.localClippingEnabled = true; // í´ë¦¬í•‘ í™œì„±í™”
            viewportDiv.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(100, 100, 50);
            scene.add(directionalLight1);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-100, 50, -50);
            scene.add(directionalLight2);

            // Grid
            gridHelper = new THREE.GridHelper(500, 50, 0xcccccc, 0xeeeeee);
            scene.add(gridHelper);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 50;
            controls.maxDistance = 1000;

            // ìŠ¤ì¼ˆë ˆí†¤ ë°ì´í„° ë¡œë“œ
            loadSkeletonData(model.skeletonFile);
            
            // ëª¨ë¸ ë¡œë“œ
            loadModel(model.file);
        }

        // ìŠ¤ì¼ˆë ˆí†¤ ë°ì´í„° ë¡œë“œ
        function loadSkeletonData(skeletonFile) {
            console.log(`Loading skeleton data from ${skeletonFile}...`);
            
            fetch(skeletonFile)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log(`Voted ensemble skeleton data loaded successfully`);
                    skeletonData = data;
                    
                    // í’ˆì§ˆ ì •ë³´ í‘œì‹œ
                    updateQualityInfo(data);
                    
                    // ë©”ì‹œê°€ ì´ë¯¸ ë¡œë“œëœ ê²½ìš° ìŠ¤ì¼ˆë ˆí†¤ ì¶”ê°€
                    if (mesh) {
                        addSkeletonToScene();
                    }
                })
                .catch(error => {
                    console.warn(`Skeleton data loading failed:`, error);
                    console.log(`Viewer will work without skeleton visualization`);
                    skeletonData = null;
                });
        }

        // ìŠ¤ì¼ˆë ˆí†¤ ì¶”ê°€
        function addSkeletonToScene() {
            if (!skeletonData || !skeletonData.points) {
                console.log('No skeleton data available');
                return;
            }
            
            // ê¸°ì¡´ ìŠ¤ì¼ˆë ˆí†¤ ì œê±°
            if (skeleton) {
                scene.remove(skeleton);
                skeleton = null;
            }
            
            // ë©”ì‹œê°€ ì—†ìœ¼ë©´ ìŠ¤ì¼ˆë ˆí†¤ë„ ì¶”ê°€í•˜ì§€ ì•ŠìŒ
            if (!mesh) {
                return;
            }
            
            // ë©”ì‹œì˜ ë°”ìš´ë”© ë°•ìŠ¤ ê³„ì‚°
            const meshBox = new THREE.Box3().setFromObject(mesh);
            const meshCenter = meshBox.getCenter(new THREE.Vector3());
            const meshSize = meshBox.getSize(new THREE.Vector3());
            
            // ìŠ¤ì¼ˆë ˆí†¤ì˜ ì›ë˜ ë°”ìš´ë”© ë°•ìŠ¤ ê³„ì‚°
            let skeletonMinX = Infinity, skeletonMinY = Infinity, skeletonMinZ = Infinity;
            let skeletonMaxX = -Infinity, skeletonMaxY = -Infinity, skeletonMaxZ = -Infinity;
            let skeletonCenterX = 0, skeletonCenterY = 0, skeletonCenterZ = 0;
            let pointCount = 0;
            
            for (const [name, point] of Object.entries(skeletonData.points)) {
                skeletonMinX = Math.min(skeletonMinX, point.x);
                skeletonMinY = Math.min(skeletonMinY, point.y);
                skeletonMinZ = Math.min(skeletonMinZ, point.z);
                skeletonMaxX = Math.max(skeletonMaxX, point.x);
                skeletonMaxY = Math.max(skeletonMaxY, point.y);
                skeletonMaxZ = Math.max(skeletonMaxZ, point.z);
                
                skeletonCenterX += point.x;
                skeletonCenterY += point.y;
                skeletonCenterZ += point.z;
                pointCount++;
            }
            
            if (pointCount > 0) {
                skeletonCenterX /= pointCount;
                skeletonCenterY /= pointCount;
                skeletonCenterZ /= pointCount;
            }
            
            const skeletonSizeY = skeletonMaxY - skeletonMinY;
            
            // ìŠ¤ì¼€ì¼ ê³„ì‚°
            let scale;
            if (skeletonData.mesh_info && skeletonData.mesh_info.height) {
                const originalMeshHeight = skeletonData.mesh_info.height;
                const currentMeshHeight = meshSize.y;
                scale = currentMeshHeight / originalMeshHeight;
                console.log(`Original mesh height: ${originalMeshHeight}, Current: ${currentMeshHeight}, Scale: ${scale}`);
            } else {
                scale = (meshSize.y / skeletonSizeY) * 0.9;
                console.log(`Using fallback scale calculation: ${scale}`);
            }
            
            // ì˜¤í”„ì…‹ ê³„ì‚°
            const offsetX = -skeletonCenterX;
            const offsetY = -skeletonCenterY;
            
            // Zì¶• ì˜¤í”„ì…‹: ì²™ì¶”ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë’¤ë¡œ ì´ë™
            // ê³¨ë°˜ê³¼ ì–´ê¹¨ëŠ” ë” ë’¤ë¡œ, ì²™ì¶”ëŠ” ì¡°ê¸ˆ ë’¤ë¡œ ì´ë™
            const baseOffsetZ = -skeletonCenterZ;
            const pelvisBackOffset = -6; // ê³¨ë°˜ ì¶”ê°€ í›„ë°© ì´ë™
            const shoulderBackOffset = -10;  // ì–´ê¹¨ ì¶”ê°€ í›„ë°© ì´ë™
            const spineBackOffset = -5;  // ì²™ì¶” ì¶”ê°€ í›„ë°© ì´ë™
            const neckBackOffset = -5;  // ëª© ì¶”ê°€ í›„ë°© ì´ë™
            
            const yAdjustment = meshSize.y * 0.15;
            
            console.log(`Mesh size:`, meshSize);
            console.log(`Scale: ${scale}, Y adjustment: ${yAdjustment}`);
            console.log(`Base Z offset: ${baseOffsetZ}, Additional offsets - Pelvis: ${pelvisBackOffset}, Shoulder: ${shoulderBackOffset}, Spine: ${spineBackOffset}`);
            
            // ìŠ¤ì¼ˆë ˆí†¤ ê·¸ë£¹ ìƒì„±
            const skeletonGroup = new THREE.Group();
            
            // ìŠ¤ì¼ˆë ˆí†¤ í¬ì¸íŠ¸ ìƒì„±
            const pointsGeometry = new THREE.BufferGeometry();
            const pointsPositions = [];
            const pointsColors = [];
            
            for (const [name, point] of Object.entries(skeletonData.points)) {
                // ëª© ë¶€ë¶„(neck, head) ìŠ¤ì¼ˆë ˆí†¤ í¬ì¸íŠ¸ëŠ” ê±´ë„ˆë›°ê¸° (cervicalì€ ìœ ì§€)
                if (name.includes('neck') || name.includes('head')) {
                    continue;
                }
                
                // ë¶€ìœ„ë³„ Zì¶• ì¶”ê°€ ì˜¤í”„ì…‹ ê³„ì‚°
                let additionalZOffset = 0;
                
                // ê³¨ë°˜ (pelvis_center, sacrum, left_hip, right_hip)
                if (name.includes('pelvis') || name.includes('hip') || name.includes('sacr') || name.includes('coccyx')) {
                    additionalZOffset = pelvisBackOffset;
                } 
                // ì–´ê¹¨ (shoulder_center, left_shoulder, right_shoulder)
                else if (name.includes('shoulder')) {
                    additionalZOffset = shoulderBackOffset;
                } 
                // ì²™ì¶” (thoracic, lumbar)
                else if (name.includes('thoracic') || name.includes('lumbar')) {
                    additionalZOffset = spineBackOffset;
                }
                // ê²½ì¶” (cervical)
                else if (name.includes('cervical')) {
                    additionalZOffset = neckBackOffset;
                }
                
                pointsPositions.push(
                    (point.x + offsetX) * scale,
                    (point.y + offsetY) * scale + yAdjustment,
                    (point.z + baseOffsetZ + additionalZOffset) * scale
                );
                pointsColors.push(1.0, 0.0, 0.0); // ë¹¨ê°„ìƒ‰ (ì•™ìƒë¸” íˆ¬í‘œ ê²°ê³¼ ê°•ì¡°)
            }
            
            pointsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(pointsPositions, 3));
            pointsGeometry.setAttribute('color', new THREE.Float32BufferAttribute(pointsColors, 3));
            
            const pointsMaterial = new THREE.PointsMaterial({
                size: 15,  // ë” í° í¬ì¸íŠ¸ë¡œ ê°•ì¡°
                vertexColors: true,
                sizeAttenuation: false,
                depthTest: false
            });
            
            const points = new THREE.Points(pointsGeometry, pointsMaterial);
            skeletonGroup.add(points);
            
            // ìŠ¤ì¼ˆë ˆí†¤ ì—°ê²°ì„  ìƒì„±
            if (skeletonData.connections) {
                skeletonData.connections.forEach(connection => {
                    const [start, end] = connection;
                    
                    if (skeletonData.points[start] && skeletonData.points[end]) {
                        // ëª© ë¶€ë¶„ ì—°ê²°ì„ ì€ ê±´ë„ˆë›°ê¸° (neck, headë§Œ ì œì™¸, cervicalì€ ìœ ì§€)
                        if (start.includes('neck') || start.includes('head') ||
                            end.includes('neck') || end.includes('head')) {
                            return;
                        }
                        
                        // ì²™ì¶” ë©”ì¸ ë¼ì¸ ì—°ê²°ì€ ê±´ë„ˆë›°ê¸° (ë‚˜ì¤‘ì— ì£¼í™©ìƒ‰ êµµì€ ì›í†µìœ¼ë¡œ ê·¸ë¦¼)
                        const spineNames = [
                            'cervical_C1', 'cervical_C2', 'cervical_C3', 'cervical_C4', 'cervical_C5', 'cervical_C6', 'cervical_C7',
                            'thoracic_T1', 'thoracic_T2', 'thoracic_T3', 'thoracic_T4', 'thoracic_T5', 'thoracic_T6',
                            'thoracic_T7', 'thoracic_T8', 'thoracic_T9', 'thoracic_T10', 'thoracic_T11', 'thoracic_T12',
                            'lumbar_L1', 'lumbar_L2', 'lumbar_L3', 'lumbar_L4', 'lumbar_L5',
                            'sacral_S1', 'sacral_S2', 'sacral_S3', 'sacral_S4', 'sacral_S5'
                        ];
                        
                        // ì²™ì¶” ë©”ì¸ ë¼ì¸ì˜ ì—°ì†ëœ ì—°ê²°ì¸ì§€ í™•ì¸
                        const startIdx = spineNames.indexOf(start);
                        const endIdx = spineNames.indexOf(end);
                        if (startIdx !== -1 && endIdx !== -1 && Math.abs(startIdx - endIdx) === 1) {
                            return; // ì²™ì¶” ë©”ì¸ ë¼ì¸ ì—°ê²°ì€ ê±´ë„ˆë›°ê¸°
                        }
                        
                        const startPoint = skeletonData.points[start];
                        const endPoint = skeletonData.points[end];
                        
                        // ì‹œì‘ì ì˜ ì¶”ê°€ Zì¶• ì˜¤í”„ì…‹
                        let startAdditionalZ = 0;
                        if (start.includes('pelvis') || start.includes('hip') || start.includes('sacr') || start.includes('coccyx')) {
                            startAdditionalZ = pelvisBackOffset;
                        } else if (start.includes('shoulder')) {
                            startAdditionalZ = shoulderBackOffset;
                        } else if (start.includes('thoracic') || start.includes('lumbar')) {
                            startAdditionalZ = spineBackOffset;
                        } else if (start.includes('cervical')) {
                            startAdditionalZ = neckBackOffset;
                        }
                        
                        // ëì ì˜ ì¶”ê°€ Zì¶• ì˜¤í”„ì…‹
                        let endAdditionalZ = 0;
                        if (end.includes('pelvis') || end.includes('hip') || end.includes('sacr') || end.includes('coccyx')) {
                            endAdditionalZ = pelvisBackOffset;
                        } else if (end.includes('shoulder')) {
                            endAdditionalZ = shoulderBackOffset;
                        } else if (end.includes('thoracic') || end.includes('lumbar')) {
                            endAdditionalZ = spineBackOffset;
                        } else if (end.includes('cervical')) {
                            endAdditionalZ = neckBackOffset;
                        }
                        
                        const startPos = new THREE.Vector3(
                            (startPoint.x + offsetX) * scale,
                            (startPoint.y + offsetY) * scale + yAdjustment,
                            (startPoint.z + baseOffsetZ + startAdditionalZ) * scale
                        );
                        
                        const endPos = new THREE.Vector3(
                            (endPoint.x + offsetX) * scale,
                            (endPoint.y + offsetY) * scale + yAdjustment,
                            (endPoint.z + baseOffsetZ + endAdditionalZ) * scale
                        );
                        
                        const direction = new THREE.Vector3().subVectors(endPos, startPos);
                        const length = direction.length();
                        const cylinderGeometry = new THREE.CylinderGeometry(2.5, 2.5, length, 8);
                        const cylinderMaterial = new THREE.MeshPhongMaterial({
                            color: 0xff6600,  // ì£¼í™©ìƒ‰ (ì•™ìƒë¸” ê°•ì¡°)
                            emissive: 0xff3300,
                            emissiveIntensity: 0.3,
                            shininess: 100,
                            depthTest: false
                        });
                        
                        const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
                        cylinder.position.copy(startPos).add(direction.multiplyScalar(0.5));
                        cylinder.quaternion.setFromUnitVectors(
                            new THREE.Vector3(0, 1, 0),
                            direction.normalize()
                        );
                        
                        cylinder.renderOrder = 998;
                        skeletonGroup.add(cylinder);
                    }
                });
            }
            
            // ì²™ì¶” ë©”ì¸ ë¼ì¸ ê°•ì¡° (ì£¼í™©ìƒ‰ êµµì€ ì›í†µ)
            const spinePoints = [];
            const spineOrder = [
                'cervical_C1', 'cervical_C2', 'cervical_C3', 'cervical_C4', 'cervical_C5', 'cervical_C6', 'cervical_C7',
                'thoracic_T1', 'thoracic_T2', 'thoracic_T3', 'thoracic_T4', 'thoracic_T5', 'thoracic_T6',
                'thoracic_T7', 'thoracic_T8', 'thoracic_T9', 'thoracic_T10', 'thoracic_T11', 'thoracic_T12',
                'lumbar_L1', 'lumbar_L2', 'lumbar_L3', 'lumbar_L4', 'lumbar_L5',
                'sacral_S1', 'sacral_S2', 'sacral_S3', 'sacral_S4', 'sacral_S5'
            ];
            
            console.log('=== ì²™ì¶” ë©”ì¸ ë¼ì¸ ìƒì„± ì‹œì‘ ===');
            
            // ì²™ì¶” í¬ì¸íŠ¸ ìˆ˜ì§‘
            for (const name of spineOrder) {
                if (skeletonData.points[name]) {
                    const point = skeletonData.points[name];
                    
                    // ë¶€ìœ„ë³„ Zì¶• ì˜¤í”„ì…‹
                    let additionalZOffset = 0;
                    if (name.includes('cervical')) {
                        additionalZOffset = neckBackOffset;
                    } else if (name.includes('thoracic')) {
                        additionalZOffset = spineBackOffset;
                    } else if (name.includes('lumbar')) {
                        additionalZOffset = spineBackOffset;
                    } else if (name.includes('sacr')) {
                        additionalZOffset = pelvisBackOffset;
                    }
                    
                    const pos = new THREE.Vector3(
                        (point.x + offsetX) * scale,
                        (point.y + offsetY) * scale + yAdjustment,
                        (point.z + baseOffsetZ + additionalZOffset) * scale
                    );
                    spinePoints.push(pos);
                    console.log(`ì²™ì¶” í¬ì¸íŠ¸ ì¶”ê°€: ${name}`, pos);
                }
            }
            
            console.log(`ì´ ì²™ì¶” í¬ì¸íŠ¸ ìˆ˜: ${spinePoints.length}`);
            
            // ì²™ì¶” ë©”ì¸ ë¼ì¸ ê·¸ë¦¬ê¸° (êµµì€ ì£¼í™©ìƒ‰ ì›í†µ)
            for (let i = 0; i < spinePoints.length - 1; i++) {
                const startPos = spinePoints[i];
                const endPos = spinePoints[i + 1];
                
                const direction = new THREE.Vector3().subVectors(endPos, startPos);
                const length = direction.length();
                
                console.log(`ì²™ì¶” ì›í†µ ${i}: ê¸¸ì´ ${length.toFixed(2)}`);
                
                // êµµì€ ì£¼í™©ìƒ‰ ì›í†µ (íˆ¬ëª…í•˜ê³  ì ë‹¹í•œ í¬ê¸°)
                const spineGeometry = new THREE.CylinderGeometry(3, 3, length, 8);
                const spineMaterial = new THREE.MeshPhongMaterial({
                    color: 0xff6600,  // ë°ì€ ì£¼í™©ìƒ‰
                    emissive: 0xff4400,
                    emissiveIntensity: 0.6,
                    shininess: 100,
                    transparent: true,
                    opacity: 0.7,
                    depthTest: false,  // ë©”ì‹œë¥¼ ê´€í†µí•´ì„œ ë³´ì„
                    side: THREE.DoubleSide
                });
                
                const spineCylinder = new THREE.Mesh(spineGeometry, spineMaterial);
                spineCylinder.position.copy(startPos).add(direction.multiplyScalar(0.5));
                spineCylinder.quaternion.setFromUnitVectors(
                    new THREE.Vector3(0, 1, 0),
                    direction.normalize()
                );
                
                spineCylinder.renderOrder = 1000; // ë‹¤ë¥¸ ìŠ¤ì¼ˆë ˆí†¤ë³´ë‹¤ ì•ì— í‘œì‹œ
                skeletonGroup.add(spineCylinder);
            }
            
            console.log(`ì²™ì¶” ì›í†µ ${spinePoints.length - 1}ê°œ ìƒì„± ì™„ë£Œ`);
            console.log('=== ì²™ì¶” ë©”ì¸ ë¼ì¸ ìƒì„± ì™„ë£Œ ===');
            
            skeleton = skeletonGroup;
            skeleton.renderOrder = 999;
            scene.add(skeleton);
            
            console.log('Voted ensemble skeleton added to scene with highlighted spine');
        }

        // ëª¨ë¸ ë¡œë“œ
        function loadModel(filepath) {
            console.log(`Loading model: ${filepath}`);
            const loader = new OBJLoader();
            
            loader.load(
                filepath,
                (object) => {
                    console.log(`Successfully loaded model: ${filepath}`);
                    
                    // ê¸°ì¡´ ë©”ì‹œ ì œê±°
                    if (mesh) {
                        scene.remove(mesh);
                    }

                    // ì¤‘ì‹¬ ì •ë ¬
                    const box = new THREE.Box3().setFromObject(object);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    object.position.sub(center);
                    
                    // ë©”ì‰¬ë¥¼ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™ (Xì¶• ì–‘ì˜ ë°©í–¥)
                    object.position.x -= 5;

                    // í´ë¦¬í•‘ í‰ë©´ ì„¤ì • (í† ë¥´ì†Œë§Œ ë³´ì´ë„ë¡)
                    // 1. ë¬´ë¦ ì•„ë˜ ìë¥´ê¸° (Yì¶• ê¸°ì¤€ - í•˜ì²´ í•˜ë‹¨ë¶€)
                    const kneeHeight = -size.y * 0.2; // ì¤‘ì‹¬ ê¸°ì¤€ ì•„ë˜ìª½ 20% ì§€ì 
                    const clipPlaneKnee = new THREE.Plane(new THREE.Vector3(0, 1, 0), -kneeHeight);
                    
                    // 2. íŒ” ìë¥´ê¸° - ì–´ê¹¨ì—ì„œ ì‚´ì§ ì•„ë˜ (Xì¶• ì–‘ìª½)
                    const shoulderWidth = size.x * 0.25; // ì–´ê¹¨ ë„ˆë¹„ (ì¤‘ì‹¬ì—ì„œ 25%)
                    const shoulderHeight = size.y * 0.25; // ì–´ê¹¨ ë†’ì´ (ì¤‘ì‹¬ì—ì„œ ìœ„ìª½ 25%)
                    
                    // ì™¼ìª½ íŒ” ìë¥´ê¸° (X < -shoulderWidthì¸ ë¶€ë¶„ ì¤‘ ì–´ê¹¨ ì•„ë˜)
                    const clipPlaneLeftArm = new THREE.Plane(new THREE.Vector3(1, 0, 0), shoulderWidth);
                    
                    // ì˜¤ë¥¸ìª½ íŒ” ìë¥´ê¸° (X > shoulderWidthì¸ ë¶€ë¶„ ì¤‘ ì–´ê¹¨ ì•„ë˜)
                    const clipPlaneRightArm = new THREE.Plane(new THREE.Vector3(-1, 0, 0), shoulderWidth);
                    
                    const clippingPlanes = [clipPlaneKnee, clipPlaneLeftArm, clipPlaneRightArm];

                    // ì¬ì§ˆ ì„¤ì • (í´ë¦¬í•‘ ì ìš©)
                    object.traverse((child) => {
                        if (child instanceof THREE.Mesh) {
                            child.material = new THREE.MeshPhongMaterial({
                                color: 0xb8d4ff,
                                specular: 0x111111,
                                shininess: 30,
                                flatShading: false,
                                clippingPlanes: clippingPlanes,
                                clipShadows: true
                            });
                        }
                    });

                    scene.add(object);
                    mesh = object;

                    // ì •ë³´ í‘œì‹œ
                    updateInfo(object);
                    
                    // ìŠ¤ì¼ˆë ˆí†¤ ì¶”ê°€ (ë°ì´í„°ê°€ ì´ë¯¸ ë¡œë“œëœ ê²½ìš°)
                    if (skeletonData) {
                        addSkeletonToScene();
                    }

                    // ë¡œë”© ì™„ë£Œ
                    document.getElementById('loading').classList.add('hidden');
                },
                (xhr) => {
                    const percent = xhr.total > 0 ? (xhr.loaded / xhr.total * 100).toFixed(2) : 'N/A';
                    console.log(`Model: ${percent}% loaded`);
                },
                (error) => {
                    console.error(`Error loading model from ${filepath}:`, error);
                    document.getElementById('info').innerHTML = `<span style="color: #ff4444;">ë¡œë“œ ì‹¤íŒ¨</span>`;
                    document.getElementById('loading').classList.add('hidden');
                }
            );
        }

        // ì •ë³´ ì—…ë°ì´íŠ¸
        function updateInfo(object) {
            let vertexCount = 0;
            let faceCount = 0;

            object.traverse((child) => {
                if (child instanceof THREE.Mesh) {
                    if (child.geometry.attributes.position) {
                        vertexCount += child.geometry.attributes.position.count;
                    }
                    if (child.geometry.index) {
                        faceCount += child.geometry.index.count / 3;
                    } else if (child.geometry.attributes.position) {
                        faceCount += child.geometry.attributes.position.count / 3;
                    }
                }
            });

            const infoDiv = document.getElementById('info');
            infoDiv.innerHTML = `
                <strong>Default Quality Mesh</strong><br>
                ì •ì : ${vertexCount.toLocaleString()}<br>
                ë©´: ${Math.floor(faceCount).toLocaleString()}
            `;
        }

        // í’ˆì§ˆ ì •ë³´ ì—…ë°ì´íŠ¸
        function updateQualityInfo(data) {
            const qualityDiv = document.getElementById('quality');
            
            if (!data || !data.quality_metrics) {
                qualityDiv.innerHTML = '<div style="color: #666;">í’ˆì§ˆ ë°ì´í„° ì—†ìŒ</div>';
                return;
            }
            
            const quality = data.quality_metrics;
            const angles = quality.angles || {};
            
            let html = '<div class="quality-title">ğŸ† ìµœì  ìŠ¤ì¼ˆë ˆí†¤ (ì•™ìƒë¸” ë³´íŒ…)</div>';
            
            if (angles.cervical_lordosis !== undefined) {
                html += `<div class="quality-metric">
                    ê²½ì¶” ì „ë§Œê°: <span class="quality-value">${angles.cervical_lordosis.toFixed(1)}Â°</span>
                </div>`;
            }
            
            if (angles.thoracic_kyphosis !== undefined) {
                html += `<div class="quality-metric">
                    í‰ì¶” í›„ë§Œê°: <span class="quality-value">${angles.thoracic_kyphosis.toFixed(1)}Â°</span>
                </div>`;
            }
            
            if (angles.lumbar_lordosis !== undefined) {
                html += `<div class="quality-metric">
                    ìš”ì¶” ì „ë§Œê°: <span class="quality-value">${angles.lumbar_lordosis.toFixed(1)}Â°</span>
                </div>`;
            }
            
            html += `<div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.2); color: #aaa; font-size: 10px;">
                6ê°œ LOD ëª¨ë¸ì˜ ì˜ˆì¸¡ì„ ì¢…í•©í•˜ì—¬<br>
                ì¤‘ì•™ê°’ ê¸°ë°˜ ë³´íŒ…ìœ¼ë¡œ ì„ íƒëœ ìµœì  ê²°ê³¼
            </div>`;
            
            qualityDiv.innerHTML = html;
        }

        // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„
        function animate() {
            requestAnimationFrame(animate);

            if (autoRotateEnabled && mesh) {
                mesh.rotation.y += 0.005;
                if (skeleton) skeleton.rotation.y += 0.005;
            }
            controls.update();
            renderer.render(scene, camera);
        }

        // ë²„íŠ¼ ì´ë²¤íŠ¸ ì„¤ì •
        function setupControls() {
            // ì¹´ë©”ë¼ ë¦¬ì…‹
            document.getElementById('resetCamera').addEventListener('click', () => {
                camera.position.set(0, 100, 300);
                controls.target.set(0, 0, 0);
                controls.update();
            });

            // ì™€ì´ì–´í”„ë ˆì„ í† ê¸€
            document.getElementById('toggleWireframe').addEventListener('click', function() {
                wireframeMode = !wireframeMode;
                this.classList.toggle('active', wireframeMode);
                
                if (mesh) {
                    mesh.traverse((child) => {
                        if (child instanceof THREE.Mesh) {
                            child.material.wireframe = wireframeMode;
                        }
                    });
                }
            });

            // ê·¸ë¦¬ë“œ í† ê¸€
            document.getElementById('toggleGrid').addEventListener('click', function() {
                showGrid = !showGrid;
                this.classList.toggle('active', !showGrid);
                gridHelper.visible = showGrid;
            });

            // ìë™ íšŒì „
            document.getElementById('autoRotate').addEventListener('click', function() {
                autoRotateEnabled = !autoRotateEnabled;
                this.classList.toggle('active', autoRotateEnabled);
            });
            
            // ìŠ¤ì¼ˆë ˆí†¤ í† ê¸€
            document.getElementById('toggleSkeleton').addEventListener('click', function() {
                showSkeleton = !showSkeleton;
                this.classList.toggle('active', showSkeleton);
                
                if (skeleton) {
                    skeleton.visible = showSkeleton;
                }
            });
        }

        // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ
        function onWindowResize() {
            const viewportDiv = document.getElementById('viewport');
            const width = viewportDiv.clientWidth;
            const height = viewportDiv.clientHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        window.addEventListener('resize', onWindowResize, false);

        // ì‹¤í–‰
        init();
        setupControls();
        animate();
    </script>
</body>
</html>